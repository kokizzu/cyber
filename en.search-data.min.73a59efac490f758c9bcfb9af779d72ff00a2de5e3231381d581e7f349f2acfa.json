[{"id":0,"href":"/cyber/docs/toc/syntax/","title":"Syntax","section":"Table of Contents","content":" Syntax # Cyber\u0026rsquo;s syntax is concise and easy to read.\nStatements. # A statement ends with the new line.\n-- An assignment statement. var a = 123 Blocks. # Some statements can start a new block with a colon. The first statement in a new block must be indented further. Spaces or tabs can be used for indentation but not both.\n-- This `if` statement begins a new block. if true: var a = 234 Subsequent statements in the block must follow the same indentation. The block ends when a statement recedes from this indentation.\nfor items -\u0026gt; it: if it == 20: print it print it + 10 print it -- This is the first statement outside of the `if` block. Single-line blocks allow only one statement after a starting block.\n-- A single line block. if true: print 123 if true: print 123 -- This is an indentation error since the single-line block is already consumed. print 234 Since blocks require at least one statement, use pass as a placeholder statement.\nfunc foo(): pass Variables. # Local variables. # Local variables exist until the end of their scope. They are declared and initialized using the var keyword:\nvar a = 123 When declared without a type specifier next to the variable, it infers the type from the right initializer. To declare variables for a specific type, see Typed variables.\nVariables can be set afterwards using the = operator:\na = 234 Dynamically typed. # Dynamically typed variables are easier to work with and there is no friction when using them. They are declared using the my keyword:\nmy a = 123 To understand more about dynamically and statically typed code, see Type System.\nVariable scopes. # Blocks create a new variable scope. Variables declared in the current scope will take precedence over any parent variables with the same name:\nfunc foo(): var a = 234 if true: var a = 345 -- New `a` declared. print a -- Prints \u0026#34;345\u0026#34; print a -- Prints \u0026#34;234\u0026#34; Static Variables. # Static variables live until the end of the script. They act as global variables and are visible from anywhere in the script.\nThey are declared with var but a namespace must be provided before the variable name:\nvar Root.a = 123 func foo(): print a -- \u0026#39;123\u0026#39; The Root symbol is used to reference the current module\u0026rsquo;s namespace.\nSince static variables are initialized outside of a fiber\u0026rsquo;s execution flow, they can not reference any local variables:\n-- Static declaration. var Root.b = a -- Compile error, initializer can not reference a local variable. -- Main execution. var a = 123 However, they can be reassigned after initialization:\nvar Root.b = 0 var a = 123 b = a -- Reassigning after initializing. Static variable initializers have a natural order based on when it was encountered by the compiler. In the case of imported variables, the order of the import would affect this order. The following would print \u0026lsquo;123\u0026rsquo; before \u0026lsquo;234\u0026rsquo;:\nvar Root.a = print(123) var Root.b = print(234) When the initializers reference other static variables, those child references are initialized first in DFS order and supersede the natural ordering. The following initializes b before a.\nvar Root.a = b + 321 var Root.b = 123 print a -- \u0026#39;444\u0026#39; Circular references in initializers are not allowed. When initialization encounters a reference that creates a circular dependency an error is reported.\nvar Root.a = b var Root.b = a -- CompileError. Referencing `a` creates a circular dependency. Sometimes, you may want to initialize a static variable by executing multiple statements in order. For this use case, you can use a declaration block. *Planned Feature\nvar Root.myImage =: var img = loadImage(\u0026#39;me.png\u0026#39;) img.resize(100, 100) img.filter(.blur, 5) break img The final resulting value that is assigned to the static variable is provided by a break statement. If a break statement is not provided, none is assigned instead.\nReserved identifiers. # Keywords. # There are 25 general keywords. This list categorizes them:\nControl Flow: if else switch case while for break continue pass Operators: or and not Variables: var my Functions: func return Coroutines: coinit coyield, coresume Data Types: type as Error Handling: try catch throw Modules: import Contextual keywords. # These keywords only have meaning in a certain context.\nMethods: self, Self Catching Errors: caught Object Type: object Enum Type: enum Function Throws: throws Symbols. # Modules: Root Literals. # Booleans: true false Error Values: error None: none Operators. # Cyber supports the following operators. They are ordered from highest to lowest precedence.\nOperator Description \u0026lt;\u0026lt; \u0026gt;\u0026gt; Bitwise left shift, right shift. \u0026amp; Bitwise and. | || Bitwise or, exclusive or. ^ Power. / % * Division, modulus, multiplication. + - Addition, subtraction. as Type casting. \u0026gt; \u0026gt;= \u0026lt; \u0026lt;= != == Greater, greater or equal, less, less or equal, not equals, equals. and Logical and. or Logical or. Arithmetic Operators. # The following arithmetic operators are supported for the numeric data types.\n1 + 2 -- Addition, evaluates to 3. 100 - 10 -- Subtraction, evaluates to 90. 3 * 4 -- Multiplication, evaluates to 12. 20 / 5 -- Division, evaluates to 4. 2 ^ 4 -- Raise to the power, evaluates to 16. 12 % 5 -- Modulus remainder, evaluates to 2. -(10) -- Apply negative, evaluates to -10. Comparison Operators. # Cyber supports the following comparison operators. By default, a comparison operator evaluates to a Boolean value.\nThe equals operator returns true if the two values are equal. For primitive types, the comparison checks the types and the underlying value. For strings, the underlying bytes are compared for equality. For objects, the comparison checks that the two values reference the same object.\n1 == 1 -- Evaluates to `true` 1 == 2 -- Evaluates to `false` 1 == true -- Evaluates to `false` var a = \u0026#39;abc\u0026#39; a == \u0026#39;abc\u0026#39; -- Evaluates to `true` a = [] b = a a == b -- Evaluates to `true` a == [] -- Evaluates to `false` The not equals operator returns true if the two values are not equal.\n1 != 1 -- Evaluates to `false` 1 != 2 -- Evaluates to `true` Number types have additional comparison operators.\na \u0026gt; b -- `true` if a is greater than b a \u0026gt;= b -- `true` if a is greater than or equal to b a \u0026lt; b -- `true` if a is less than b a \u0026lt;= b -- `true` if a is less than or equal to b Logic Operators. # The logical operators and, or, and not are supported.\nand evaluates to a if a is not truthy. Otherwise, it evaluates to b. If a is not truthy, the evaluation of b is not executed. A numeric value that isn\u0026rsquo;t 0 is truthy. An object reference is always truthy. The none value is not truthy.\ntrue and true -- Evaluates to true 123 and 234 -- Evaluates to 234 123 and 0 -- Evaluates to false or evaluates to a if a is truthy. Otherwise, it evaluates to b. If a is found to be truthy, the evaluation of b is not executed.\ntrue or false -- Evaluates to true false or true -- Evaluates to true false or false -- Evaluates to false 123 or false -- Evaluates to 123 The unary operator not performs negation on the boolean value. The unary operator ! can also be used instead of not.\nnot false -- Evaluates to true not true -- Evaluates to false not 0 -- Evaluates to true not 123 -- Evaluates to false !false -- Evaluates to true !true -- Evaluates to false Bitwise Operators. # The following bitwise operators are supported for int number values.\n-- Bitwise and: any underlying bits that are set in both integers are set in the new integer. a \u0026amp; b -- Bitwise or: any underlying bits that are set in either integer a or integer b are set in the new integer. a | b -- Bitwise exclusive or: any underlying bits that are set in either integer a or integer b but not both are set in the new integer. a || b -- Bitwise right shift: a\u0026#39;s bits are shifted b bits to the least significant end. This performs sign-extension on the 32-bit integer. a \u0026gt;\u0026gt; b -- Bitwise left shift: a\u0026#39;s bits are shifted b bits to the most significant end. This does not perform sign-extension on the 32-bit integer. a \u0026lt;\u0026lt; b -- Bitwise not: a\u0026#39;s integer bits are flipped. ~a Operator Overloading. # See Operator Overloading in Metaprogramming.\nComments. # A single line comment starts with two hyphens and ends at the end of the line.\n-- This is a comment. var a = 123 -- This is a comment on the same line as a statement. There will be multi-line comments in Cyber but the syntax has not been determined.\nCYON. # CYON or the Cyber object notation is similar to JSON. The format uses the same literal value semantics as Cyber.\n[ name: \u0026#39;John Doe\u0026#39;, \u0026#39;age\u0026#39;: 25, -- This is a comment cities: [ \u0026#39;New York\u0026#39;, \u0026#39;San Francisco\u0026#39;, \u0026#39;Tokyo\u0026#39;, ], ] "},{"id":1,"href":"/cyber/docs/toc/data-types/","title":"Data Types","section":"Table of Contents","content":" Data Types. # In Cyber, there are primitive types and object types. Primitives are copied around by value and don\u0026rsquo;t need additional heap memory or reference counts.\nPrimitives include Booleans, Floats, Integers, Enums, Symbols, Error Symbols, and the none value.\nObject types include Lists, Tuples, Maps, Strings, Arrays, User Objects, Lambdas, Fibers, Enums with payloads, Pointers, and several internal object types.\nNone. # The none value represents an empty value. This is similar to null in other languages.\nBooleans. # Booleans can be true or false. See type bool.\nvar a = true if a: print \u0026#39;a is true\u0026#39; When other value types are coerced to the bool type, the truthy value is determined as follows.\nThe none value is false. Other objects and values are always true. Numbers. # Integers. # int is the default integer type. It has 48-bits and can represent integers in the range -(247) to 247-1. See type int.\nWhen a numeric literal is used and the type can not be inferred, it will default to the int type:\nvar a = 123 Integer notations always produce a int value:\nvar a = 0xFF -- hex. a = 0o17 -- octal. a = 0b1010 -- binary. a = `🐶` -- UTF-8 rune. Arbitrary values can be converted to a int using the type as a function.\nvar a = \u0026#39;123\u0026#39; var b = int(a) In addition to arithmetic operations, integers can also perform bitwise operations.\nFloats. # float is the default floating point type. It has a (IEEE 754) 64-bit floating point format. See type float.\nAlthough a float represents a decimal number, it can also represent integers between -(253-1) and (253-1). Any integers beyond the safe integer range is not guaranteed to have a unique representation.\nA numeric literal can be used to create a float if the inferred type is a float:\nvar a float = 123 Decimal and scientific notations always produce a float value:\nvar a = 2.34567 var b = 123.0e4 Arbitrary values can be converted to a float using the type as a function.\nvar a = \u0026#39;12.3\u0026#39; var b = float(a) Big Numbers. # Planned Feature\nStrings. # The string type represents a sequence of UTF-8 codepoints, also known as runes. Each rune is stored internally as 1-4 bytes and can be represented as an int. See type string.\nUnder the hood, there are multiple string implementations to make operations faster by default.\nStrings are immutable, so operations that do string manipulation return a new string. By default, small strings are interned to reduce memory footprint.\nTo mutate an existing string, use MutString. *Planned Feature\nA string is always UTF-8 validated. Using an Array to represent raw bytes of a string is faster but you\u0026rsquo;ll have to validate them and take care of indexing.\nA single line string literal is surrounded in single quotes.\nvar apple = \u0026#39;a fruit\u0026#39; You can escape the single quote inside the literal or use double quotes.\nvar apple = \u0026#39;Bob\\\u0026#39;s fruit\u0026#39; apple = \u0026#34;Bob\u0026#39;s fruit\u0026#34; Concatenate two strings together with the + operator or the method concat.\nvar res = \u0026#39;abc\u0026#39; + \u0026#39;xyz\u0026#39; res = res.concat(\u0026#39;end\u0026#39;) Strings are UTF-8 encoded.\nvar str = \u0026#39;abc🦊xyz🐶\u0026#39; Use double quotes to surround a multi-line string.\nvar str = \u0026#34;line a line b line c\u0026#34; You can escape double quotes inside the literal or use triple quotes.\nvar str = \u0026#34;line a line \\\u0026#34;b\\\u0026#34; line c\u0026#34; -- Using triple quotes. str = \u0026#39;\u0026#39;\u0026#39;line a line \u0026#34;b\u0026#34; line c \u0026#39;\u0026#39;\u0026#39; The following escape sequences are supported:\nEscape Sequence Code Description \\a 0x07 Terminal bell. \\b 0x08 Backspace. \\e 0x1b Escape character. \\n 0x0a Line feed character. \\r 0x0d Carriage return character. \\t 0x09 Horizontal tab character. The boundary of each line can be set with a vertical line character. This makes it easier to see the whitespace. *Planned Feature\nvar poem = \u0026#34;line a | two spaces from the left | indented further\u0026#34; Using the index operator will return the UTF-8 rune at the given index as a slice. This is equivalent to calling the method sliceAt().\nvar str = \u0026#39;abcd\u0026#39; print str[1] -- \u0026#34;b\u0026#34; print str[-1] -- \u0026#34;d\u0026#34; Using the slice operator will return a view of the string at the given start and end (exclusive) indexes. The start index defaults to 0 and the end index defaults to the string\u0026rsquo;s length.\nvar str = \u0026#39;abcxyz\u0026#39; var sub = str[0..3] print sub -- \u0026#34;abc\u0026#34; print str[..5] -- \u0026#34;abcxy\u0026#34; print str[1..] -- \u0026#34;bcxyz\u0026#34; -- One way to use slices is to continue a string operation. str = \u0026#39;abcabcabc\u0026#39; var i = str.findRune(`c`) print(i) -- \u0026#34;2\u0026#34; i += 1 print(i + str[i..].findRune(`c`)) -- \u0026#34;5\u0026#34; String Interpolation. # Expressions can be embedded into string templates with $():\nvar name = \u0026#39;Bob\u0026#39; var points = 123 var str = \u0026#39;Scoreboard: $(name) $(points)\u0026#39; String templates can not contain nested string templates.\nString formatting. # Values that can be formatted into a string will have a fmt method:\nvar file = os.openFile(\u0026#39;data.bin\u0026#39;, .read) var bytes = file.readToEnd() -- Dump contents in hex. print \u0026#39;$(bytes.fmt(.x))\u0026#39; Arrays. # An array is an immutable sequence of bytes. It can be used to represent strings but it won\u0026rsquo;t automatically validate their encoding and indexing returns the n\u0026rsquo;th byte rather than a UTF-8 rune. See type array.\nvar a = array(\u0026#39;abcd\u0026#39;) str = a.insertByte(1, 255) print a[0] -- \u0026#34;97\u0026#34; print a[1] -- \u0026#34;255\u0026#34; print a[-1] -- \u0026#34;100\u0026#34; Bracket literals. # Bracket literals are delimited with brackets []. They are used to initialize Lists, Maps, and Objects:\nvar list = [1, 2, 3] var map = [ a: 123, b: 234 ] var obj = [MyObject a: 123, b: 234] Lists. # Lists are a builtin type that holds an ordered collection of elements. Lists grow or shrink as you insert or remove elements. See type List.\n-- Construct a new list. var list = [1, 2, 3] -- The first element of the list starts at index 0. print list[0] -- Prints \u0026#39;1\u0026#39; -- Using a negative index starts at the back of the list. print list[-1] -- Prints \u0026#39;3\u0026#39; Lists can be sliced with the range .. clause. The sliced list becomes a new list that you can modify without affecting the original list. The end index is non-inclusive.\nvar list = [ 1, 2, 3, 4, 5 ] list[0..0] -- [] list[0..3] -- [ 1, 2, 3 ] list[3..] -- [ 4, 5 ] list[..3] -- [ 1, 2, 3 ] The +.. invokes the slice operator with an end position that is an increment from the start: *Planned Feature\nvar list = [ 1, 2, 3, 4, 5 ] list[2+..2] -- [ 3, 4 ] List operations.\nvar list = [234] -- Append a value. list.append 123 print list[-1] -- Prints \u0026#39;123\u0026#39; -- Inserting a value at an index. list.insert(1, 345) -- Get the length. print list.len() -- Prints \u0026#39;2\u0026#39; -- Sort the list in place. list.sort((a, b) =\u0026gt; a \u0026lt; b) -- Iterating a list. for list -\u0026gt; it: print it -- Remove an element at a specific index. list.remove(1) Tuples. # Incomplete: Tuples can only be created from @host funcs at the moment.\nMaps. # Maps are a builtin type that store key value pairs in dictionaries. See type Map.\nCreate map. # Create a map using key value pairs inside a collection literal:\nvar map = [ a: 123, b: () =\u0026gt; 5 ] Maps entries can be listed in multiple lines:\nmap = [ foo: 1, bar: 2, ] Empty map. # The empty map is initialized using [:]:\nvar empty = [:] Map indexing. # Get a value from the map using the index operator:\nprint map[\u0026#39;a\u0026#39;] Maps can be accessed with the . dot operator as well:\nprint map.a Map operations. # var map = [:] -- Set a key value pair. map[123] = 234 -- Get the size of the map. print map.size() -- Remove an entry by key. map.remove 123 -- Iterating a map. for map -\u0026gt; [val, key]: print \u0026#39;$(key) -\u0026gt; $(value)\u0026#39; Map block. # Entries can also follow a collection literal block. This gives structure to the entries and has the added benefit of allowing multi-line lambdas. *Planned Feature\nvar colors = []: red: 0xFF0000 green: 0x00FF00 blue: 0x0000FF dump func (c): print c.red print c.green print c.blue -- Nested map. darker []: red: 0xAA0000 green: 0x00AA00 blue: 0x0000AA Objects. # Any value that isn\u0026rsquo;t a primitive is an object. You can declare your own object types using the type object declaration. Object types are similar to structs and classes in other languages. Unlike classes, there is no concept of inheritance at the language level.\nFields. # Fields must be declared at the top of the type object block using var or my:\ntype Node object: var value int var next any When fields are declared with my instead, they become dynamically typed.\nInstantiation. # New object instances are created using a leading type name and the field values in a collection literal:\nvar node = [Node value: 123, next: none] print node.value -- Prints \u0026#34;123\u0026#34; Methods. # Methods allow invoking a function on an object instance using the . operator:\ntype Node object: var value int var next any func inc(n): value += n func incAndPrint(): inc(321) print value var node = [Node value: 123, next: none] n.incAndPrint() -- Prints \u0026#34;444\u0026#34; Methods can also be declared outside of the type declaration. To distinguish a method from a type function, self must be provided as a parameter:\nfunc Node.getNext(self): return self.next self variable. # Type members can be implicitly referenced inside the method. *Incomplete: Only the type\u0026#39;s fields can be referenced this way.\nTo reference members explicitly inside a method, use the builtin self:\ntype Node object: var value int var next any func double(): return self.value * 2 Type functions. # Type functions are declared outside of the type block with an explicit namespace path:\ntype Node object: var value int var next any -- Declare namespace function inside `Node`. func Node.new(): return [Node value: 123, next: none] var n = Node.new() Type variables. # Similarily, type variables are declared outside of the type block:\n-- Declare inside the `Node` namespace. var Node.DefaultValue = 100 print Node.DefaultValue -- Prints \u0026#34;100\u0026#34; Enums. # A new enum type can be declared with the type enum declaration. An enum value can only be one of the unique symbols declared in the enum type. By default, the symbols generate unique ids starting from 0.\ntype Fruit enum: case apple case orange case banana case kiwi var fruit = Fruit.kiwi print fruit -- \u0026#39;Fruit.kiwi\u0026#39; print int(fruit) -- \u0026#39;3\u0026#39; When the type of the value is known to be an enum, it can be assigned using a symbol literal.\nvar fruit = Fruit.kiwi fruit = .orange print(fruit == Fruit.orange) -- \u0026#39;true\u0026#39; Symbols. # Symbol literals begin with ., followed by an identifier. They have their own global unique id.\nvar currency = .usd print(currency == .usd) -- \u0026#39;true\u0026#39; print int(currency) -- \u0026#39;123\u0026#39; or some arbitrary id. "},{"id":2,"href":"/cyber/docs/toc/control-flow/","title":"Control Flow","section":"Table of Contents","content":" Control Flow. # Cyber provides the common constructs to branch and enter loops.\nBranching. # if statement. # Use if and else statements to branch the execution of your code depending on conditions. The else clause can contain a condition which is only evaluated if the previous if or conditional else clause was false.\nvar a = 10 if a == 10: print \u0026#39;a is 10\u0026#39; else a == 20: print \u0026#39;a is 20\u0026#39; else: print \u0026#39;neither 10 nor 20\u0026#39; Conditional expression. # A conditional branch expression evaluates a condition and returns either the true value or false value:\nvar a = 10 var str = a == 10 ? \u0026#39;red\u0026#39; else \u0026#39;blue\u0026#39; and/or # Use and and or logical operators to combine conditions:\nvar a = 10 if a \u0026gt; 5 and a \u0026lt; 15: print \u0026#39;a is between 5 and 15\u0026#39; if a == 20 or a == 10: print \u0026#39;a is 10 or 20\u0026#39; Iterations. # Infinite loop. # The while keyword starts an infinite loop which continues to run the code in the block until a break or return is reached.\nvar count = 0 while: if count \u0026gt; 100: break count += 1 Conditional loop. # When the while clause contains a condition, the loop continues to run until the condition is evaluated to false:\n-- Keep looping until `keepRunning()` returns false. while keepRunning(): pass Unwrapping loop. # Using the capture operator -\u0026gt; unwraps the left optional value to the right variable declaration. The loop exits when the left value is none:\nvar iter = dir.walk() while iter.next() -\u0026gt; entry: print entry.name For range. # for loops can iterate over a range that starts at an int (inclusive) to a target int (exclusive). The capture operator -\u0026gt; is used to capture the loop\u0026rsquo;s counter variable:\nfor 0..4: performAction() for 0..100 -\u0026gt; i: print i -- 0, 1, 2, ... , 99 To decrement the counter instead, use -..:\nfor 100-..0 -\u0026gt; i: print i -- 100, 99, 98, ... , 1 When the range operator .. is replaced with ..=, the target int is inclusive: *Planned Feature\nfor 0..=100 -\u0026gt; i: print i -- 0, 1, 2, ... , 100 For each. # The for clause can iterate over any type that implements the Iterable trait. An Iterable contains an iterator() method which returns an Iterator object. The for loop continually invokes the Iterator\u0026rsquo;s next() method until none is returned.\nLists can be iterated since they implement the Iterable trait. The capture operator -\u0026gt; is used to capture the value returned from an iterator\u0026rsquo;s next():\nvar list = [1, 2, 3, 4, 5] for list -\u0026gt; n: print n Maps can be iterated. next() returns a key and value tuple:\nvar map = [ a: 123, b: 234 ] for map -\u0026gt; entry: print entry[0] print entry[1] Use the destructure syntax to extract the key and value into two separate variables:\nfor map -\u0026gt; [ key, val ]: print \u0026#39;key $(key) -\u0026gt; value $(val)\u0026#39; For each with index. # A counting index can be declared after the each variable. The count starts at 0 for the first value:\nvar list = [1, 2, 3, 4, 5] for list -\u0026gt; val, i: print \u0026#39;index $(i), value $(val)\u0026#39; Exit loop. # Use break to exit a loop. This loop stops printing once i reaches 4:\nfor 0..10 -\u0026gt; i: if i == 4: break print i Next iteration. # Use continue to skip the rest of the loop and go to the next iteration. This loop prints 0 through 9 but skips 4:\nfor 0..10 -\u0026gt; i: if i == 4: continue print i Switch matching. # The switch statement branches to a case block from a matching case condition. The expression that is matched against comes after switch statement. Multiple cases can be grouped together using a comma separator. An optional else fallback case is executed when no other cases were matched. *Incomplete: Not all types can be used in the case conditions such as ranges.\nvar val = 1000 switch val: case 0..100: print \u0026#39;at or between 0 and 99\u0026#39; case 100 : print \u0026#39;val is 100\u0026#39; case 200: print \u0026#39;val is 200\u0026#39; case 300, 400: print \u0026#39;combined case\u0026#39; else: print \u0026#39;val is $(val)\u0026#39; Note that the switch block must be empty and requires at least one case block or an else block to come after it.\nSwitch assignment. # Although switch can not be used freely as an expression, it can be assigned to a left variable or destination:\nvar shu = switch pepper: case \u0026#39;bell\u0026#39; =\u0026gt; 0 case \u0026#39;anaheim\u0026#39; =\u0026gt; 500 case \u0026#39;jalapeño\u0026#39; =\u0026gt; 2000 case \u0026#39;serrano\u0026#39; =\u0026gt; 10000 When declaring an assignable switch, the cases must have a return value using the syntax case {cond} =\u0026gt; {expr} or else =\u0026gt; {expr}.\nSwitch break. # A break statement exits the current case block and resumes execution after the end of the switch statement: *Planned Feature\nswitch value: case 0..5: print value if value == 3: break case print value -- Skips second print if `value` is 3. Try/Catch. # The try catch statement, try else and try expressions provide a way to catch a throwing error and resume execution in a different branch. Learn more about Error Handling.\nDeferred Execution. # Planned Feature\n"},{"id":3,"href":"/cyber/docs/toc/functions/","title":"Functions","section":"Table of Contents","content":" Functions. # In Cyber, there are first-class functions (or function values) and static functions.\nStatic Functions. # Static functions are not initially values themselves. They allow function calls to be optimal since they don\u0026rsquo;t need to resolve a dynamic value.\nStatic functions are declared with the func keyword and must have a name.\nimport math func dist(x0, y0, x1, y1): var dx = x0-x1 var dy = y0-y1 return math.sqrt(dx^2 + dy^2) Calling static functions is straightforward. You can also reassign or pass them around as function values.\nprint dist(0, 0, 10, 20) -- Assigning to a local variable. var bar = dist -- Passing `dist` as an argument. func squareDist(dist, size): return dist(0, 0, size, size) print squareDist(dist, 30) Functions can only return one value. However, the value can be destructured: *Planned Feature\nimport {cos, sin} \u0026#39;math\u0026#39; func compute(rad): return [ cos(rad), sin(rad) ] var [ x, y ] = compute(pi) Function Overloading. # Functions can be overloaded by the number of parameters in its signature. Typed functions are further overloaded by their type signatures.\nfunc foo(): return 2 + 2 func foo(n): return 10 + n func foo(n, m): return n * m print foo() -- \u0026#34;4\u0026#34; print foo(2) -- \u0026#34;12\u0026#34; print foo(20, 5) -- \u0026#34;100\u0026#34; Lambdas. # Lambdas or function values can be assigned to variables or passed as arguments into other constructs.\nWhen a lambda only returns an expression, it can be declared with a simplified syntax.\n-- Passing simple lambda as an argument. foo(word =\u0026gt; toUpper(word)) -- A simple lambda with multiple arguments. foo((word, prefix) =\u0026gt; prefix + toUpper(word)) -- Assigning a simple lambda. canvas.onUpdate = delta_ms =\u0026gt; print delta_ms Lambdas that need a block of statements can be declared with the func keyword without a name.\n-- Assigning lambda block to a variable. var add = func (a, b): return a + b -- Passing a lambda block as an argument. canvas.onUpdate(): ..func (delta_ms): print delta_ms Passing a lambda block as a call argument is only possible in a call block. See Function Calls.\nClosures. # Lambdas can capture local variables from parent blocks. This example shows the lambda f capturing a from the main scope: *Incomplete, only variables one parent block away can be captured.\nvar a = 1 var f = func(): return a + 2 print f() -- \u0026#34;3\u0026#34; The following lambda expression captures a from the function add:\nfunc add(): var a = 123 return b =\u0026gt; a + b var addTo = add() print addTo(10) -- \u0026#34;133\u0026#34; Like static variables, static functions can not reference local variables outside of their scope:\nvar a = 1 func foo(): print a -- Compile Error: Can\u0026#39;t reference local from static function. Named Parameters. # Planned Feature\nOptional Parameters. # Planned Feature\nVariadic Parameters. # Planned Feature\nFunction Calls. # The straightforward way to call a function is to use parentheses.\nvar d = dist(100, 100, 200, 200) You can call functions with named parameters.\nPlanned Feature\nvar d = dist(x0: 10, x1: 20, y0: 30, y1: 40) Shorthand syntax. # The shorthand method for calling functions omits parentheses and commas. This only works for functions that accept parameters:\nIncomplete: Only the most trivial cases work with the shorthand method. The case with operators being separated by spaces might not end up being implemented.\nvar d = dist 100 100 200 200 -- Calls the function `dist`. func random(): -- Function with no parameters. return 4 var r = random -- Returns the function itself as a value. Does not call the function `random`. r = random() -- Calls the function `random`. The top level arguments for the shorthand convention must be separated by whitespace. A string can contain whitespace since it\u0026rsquo;s surrounded by delimiters.\nvar a = myFunc \u0026#39;cyber script\u0026#39; The following has a binary expression with spaces inbetween which is not allowed. Removing that whitespace fixes the call expression.\nvar a = myFunc 1 + 2 -- Not allowed. a = myFunc 1+2 -- Correct. Wrapping arguments in parentheses allows you to keep the whitespace in the sub-expression.\n-- This calls the function `myFunc` with 2 arguments. var a = myFunc \u0026#39;hello\u0026#39; (1 + 2 * 3) -- Nested function call using the shorthand convention. a = myFunc \u0026#39;hello\u0026#39; (otherFunc 1+2 \u0026#39;world\u0026#39;) Call block syntax. # The call expression block continues to add arguments from the block\u0026rsquo;s body. If arguments are omitted from the initial call expression they can be added inside using the .. syntax. Arguments mapped to named parameters have a key value syntax separated by a :. All other arguments are added into a list and passed as the last argument.\nPlanned Feature\nfoo(123): ..func (): return 123 param3: 123 234 bar() \u0026#39;hello\u0026#39; In the example above, the function foo is called with 4 arguments. The first argument 123 is included in the starting call expression. The second argument is a function value inside the call expression block. The third argument is mapped to the param param3. Finally, the fourth argument is a list that contains 234, bar(), and 'hello'.\n"},{"id":4,"href":"/cyber/docs/toc/modules/","title":"Modules","section":"Table of Contents","content":" Modules. # Modules have their own namespace and contain accessible static symbols. By default, importing another Cyber script returns a module with its declared symbols.\nImporting. # Import declarations create a local alias to the module referenced by the import specifier. The Cyber CLI comes with some builtin modules like math and test. If the specifier does not refer to a builtin module, it looks for a Cyber script file relative to the current script\u0026rsquo;s directory. An embedder can integrate their own module loader and resolver.\nimport test test.eq(123, 123) -- Imports are static declarations so they can be anywhere in the script. import math print math.cos(0) When the alias needs to be renamed, the import specifier comes after the alias name and must be a string literal.\nimport m \u0026#39;math\u0026#39; print m.random() -- Loading a Cyber module from the local directory. import foo \u0026#39;bar.cy\u0026#39; print foo.myFunc() print foo.myVar A Cyber script that is imported doesn\u0026rsquo;t evaluate its main block. Only static declarations are effectively loaded. If there is code in the main block, it will skip evaluation. In the following, only the print statement in the main.cy is evaluated.\n-- main.cy import a \u0026#39;foo.cy\u0026#39; print a.foo -- foo.cy import \u0026#39;bar.cy\u0026#39; var Root.foo = 123 print foo -- Statement is ignored. -- bar.cy var Root.bar = 321 print bar -- Statement is ignored. You can have circular imports in Cyber. In the following example, main.cy and foo.cy import each other without any problems.\n-- main.cy import foo \u0026#39;foo.cy\u0026#39; func printB(): foo.printC() foo.printA() -- foo.cy import main \u0026#39;main.cy\u0026#39; func printA(): main.printB() func printC(): print \u0026#39;done\u0026#39; Static variable declarations from imports can have circular references. Read more about this in Static Variables.\nModules can also be destructured using the following syntax:\nPlanned Feature\nimport { cos, pi } \u0026#39;math\u0026#39; print cos(pi) Exporting. # All static declarations are exported when the script\u0026rsquo;s module is loaded.\nfunc foo(): -- Exported static function. print 123 var Root.bar = 234 -- Exported static variable. type Thing object: -- Exported type. var a float Module URI. # To get the absolute path of the current module, reference the compile-time variable ModUri. This can be used with os.dirName to get the current module directory.\nprint #ModUri -- Prints \u0026#39;/some/path/foo.cy\u0026#39; import os print os.dirName(#ModUri) -- Prints \u0026#39;/some/path\u0026#39; Visibility. # The annotation @hide provides a hint to editors that a static symbol should not appear in the auto-complete. Despite this, the symbol is still reachable.\nBuiltin Modules. # Builtin modules are the bare minimum that comes with Cyber. The embeddable library contains these modules and nothing more. They include:\nbuiltins: Cyber related functions and commonly used utilities. math: Math constants and functions. builtins. # The builtins module contains functions related to Cyber and common utilities. It is automatically imported into each script\u0026rsquo;s namespace.\nSample usage:\n-- `print` and `typeof` are available without imports. print \u0026#39;hello\u0026#39; print typeof(\u0026#39;my str\u0026#39;).id() func arrayFill(val any, n int) List Creates a list with initial capacity of n and values set to val. If the value is an object, it is shallow copied n times. func copy(val any) any Copies a primitive value or creates a shallow copy of an object value. func dump(val any) string Prints the result of toCyon on a value. func errorReport() string func isAlpha(val int) bool Returns whether a rune is an alphabetic letter. func isDigit(val int) bool Returns whether a rune is a digit. func must(val any) any If val is an error, panic(val) is invoked. Otherwise, val is returned. func panic(err any) none Stop execution in the current fiber and starts unwinding the call stack. See Unexpected Errors. func parseCyber(src string) Map Parses Cyber source string into structured map object. Currently, only metadata about static declarations is made available but this will be extended to include an AST. func parseCyon(src string) any Parses a CYON string into a value. func performGC() Map Runs the garbage collector once to detect reference cycles and abandoned objects. Returns the statistics of the run in a map value. func print(str any) none Prints a value. The host determines how it is printed. func runestr(val int) string Converts a rune to a string. func toCyon(val any) string Encodes a value to CYON string. func typeof(val any) metatype Returns the value\u0026rsquo;s type as a metatype object. func typesym(val any) symbol Returns the value\u0026rsquo;s type as one of the predefined symbols: .float, .int, .bool, .object, .list, .map, .string, .rawstring, .function, .fiber, .pointer, .symbol, .metatype, .none, .error type bool # func bool.\u0026#39;$call\u0026#39;(val any) bool Converts a value to either true or false. type error # func sym() any Return the underlying symbol. func error.\u0026#39;$call\u0026#39;(val any) error Create an error from an enum or symbol. type int # func $prefix~() int func $prefix-() int func $infix\u0026lt;(o any) bool func $infix\u0026lt;=(o any) bool func $infix\u0026gt;(o any) bool func $infix\u0026gt;=(o any) bool func $infix\u0026#43;(o any) int func $infix-(o any) int func $infix*(o any) int func $infix/(o any) int func $infix%(o any) int func $infix^(o any) int func $infix\u0026amp;(o any) int func $infix|(o any) int func $infix||(o any) int func $infix\u0026lt;\u0026lt;(o any) int func $infix\u0026gt;\u0026gt;(o any) int func int.\u0026#39;$call\u0026#39;(val any) int Converts a value to an 48-bit integer. type float # func $prefix-() float func $infix\u0026lt;(o any) bool func $infix\u0026lt;=(o any) bool func $infix\u0026gt;(o any) bool func $infix\u0026gt;=(o any) bool func $infix\u0026#43;(o any) float func $infix-(o any) float func $infix*(o any) float func $infix/(o any) float func $infix%(o any) float func $infix^(o any) float func float.\u0026#39;$call\u0026#39;(val any) float Converts the value to a float. Panics if type conversion fails. type List # func $index(idx any) any func $setIndex(idx any, val any) none func add(val any) none func append(val any) none Appends a value to the end of the list. func concat(list List) none Concats the elements of another list to the end of this list. func insert(idx int, val any) any Inserts a value at index idx. func iterator() any Returns a new iterator over the list elements. func joinString(sep any) string Returns a new string that joins the elements with separator. func len() int Returns the number of elements in the list. func remove(idx int) any Removes an element at index idx. func resize(size int) any Resizes the list to len elements. If the new size is bigger, none values are appended to the list. If the new size is smaller, elements at the end of the list are removed. type ListIterator # func next() any type tuple # func $index(idx int) any type Map # func $index(key any) any func $setIndex(key any, val any) none func remove(key any) none Removes the element with the given key key. func size() int Returns the number of key-value pairs in the map. func iterator() any Returns a new iterator over the map elements. type MapIterator # func next() any type string # func $infix\u0026#43;(o any) any func concat(o string) any Returns a new string that concats this string and str. func endsWith(suffix string) bool Returns whether the string ends with suffix. func find(needle string) any Returns the first index of substring needle in the string or none if not found. func findAnyRune(runes string) any Returns the first index of any UTF-8 rune in runes or none if not found. func findRune(rune int) int Returns the first index of UTF-8 rune needle in the string or none if not found. func insert(idx int, str string) string Returns a new string with str inserted at index idx. func isAscii() bool Returns whether the string contains all ASCII runes. func len() int Returns the number of UTF-8 runes in the string. func less(other string) bool Returns whether this string is lexicographically before other. func lower() string Returns this string in lowercase. func replace(needle string, replacement string) string Returns a new string with all occurrences of needle replaced with replacement. func repeat(n int) any Returns a new string with this string repeated n times. func runeAt(n int) any Returns the UTF-8 rune at index idx. func slice(start any, end any) any Returns a slice into this string from start to end (exclusive) indexes. This is equivalent to using the slice index operator [start..end]. func $slice(start any, end any) any func sliceAt(idx int) any Returns the UTF-8 rune at index idx as a single rune string. func $index(idx int) any func split(sep string) List Returns a list of UTF-8 strings split at occurrences of sep. func startsWith(prefix string) bool Returns whether the string starts with prefix. func trim(mode symbol, delims string) any Returns the string with ends trimmed from runes in delims. mode can be .left, .right, or .ends. func upper() string Returns this string in uppercase. func string.\u0026#39;$call\u0026#39;(val any) string Converts a value to a string. type array # func $infix\u0026#43;(o any) any func byteAt(idx int) int Returns the byte value (0-255) at the given index idx. func concat(other array) array Returns a new array that concats this array and other. func decode() any Calls decode(.utf8) func decode(encoding symbol) string Decodes the array based on an encoding. Supported encodings: .utf8. Returns the decoded string or throws error.Decode. func endsWith(suffix array) bool Returns whether the array ends with suffix. func find(needle array) any Returns the first index of needle in the array or none if not found. func findAnyByte(bytes array) any Returns the first index of any bytes in arrays or none if not found. func findByte(byte int) any Returns the first index of byte in the array or none if not found. func insert(idx int, arr array) any Returns a new array with arr inserted at index idx. func insertByte(idx int, byte int) any Returns a new array with byte inserted at index idx. func len() int Returns the number of bytes in the array. func repeat(n int) any Returns a new array with this array repeated n times. func replace(needle array, replacement array) array Returns a new array with all occurrences of needle replaced with replacement. func slice(start any, end any) any Returns a slice into this array from start to end (exclusive) indexes. This is equivalent to using the slice index operator [start..end]. func $slice(start any, end any) any func $index(idx int) int func split(sep array) List Returns a list of arrays split at occurrences of sep. func startsWith(prefix array) bool Returns whether the array starts with prefix. func trim(mode symbol, delims array) any Returns the array with ends trimmed from runes in delims. mode can be .left, .right, or .ends. func array.\u0026#39;$call\u0026#39;(val any) array Converts a string to an byte array. type pointer # func value() int Returns the memory address as an int. The value may be negative since it\u0026rsquo;s bitcasted from an unsigned 48-bit integer but it retains the original pointer bits. func pointer.\u0026#39;$call\u0026#39;(val any) pointer Converts a int to a pointer value, or casts to a pointer. This is usually used with FFI. type Fiber # func status() symbol type metatype # func id() int math. # The math module contains commonly used math constants and functions.\nSample usage:\nimport math var r = 10 print(math.pi * r^2) var e float Euler\u0026rsquo;s number and the base of natural logarithms; approximately 2.718. var inf float Infinity. var log10e float Base-10 logarithm of E; approximately 0.434. var log2e float Base-2 logarithm of E; approximately 1.443. var ln10 float Natural logarithm of 10; approximately 2.303. var ln2 float Natural logarithm of 2; approximately 0.693. var maxSafeInt float The maximum integer value that can be safely represented as a float. 2^53-1 or 9007199254740991. var minSafeInt float The minumum integer value that can be safely represented as a float. -(2^53-1) or -9007199254740991. var nan float Not a number. Note that nan == nan. However, if a nan came from an arithmetic operation, the comparison is undefined. Use isNaN instead. var neginf float Negative infinity. var pi float Ratio of a circle\u0026rsquo;s circumference to its diameter; approximately 3.14159. var sqrt1_2 float Square root of ½; approximately 0.707. var sqrt2 float Square root of 2; approximately 1.414. func abs(a float) float Returns the absolute value of x. func acos(a float) float Returns the arccosine of x. func acosh(a float) float Returns the hyperbolic arccosine of x. func asin(a float) float Returns the arcsine of x. func asinh(a float) float Returns the hyperbolic arcsine of a number. func atan(a float) float Returns the arctangent of x. func atan2(a float, b float) float Returns the arctangent of the quotient of its arguments. func atanh(a float) float Returns the hyperbolic arctangent of x. func cbrt(a float) float Returns the cube root of x. func ceil(a float) float Returns the smallest integer greater than or equal to x. func clz32(a float) float Returns the number of leading zero bits of the 32-bit integer x. func cos(a float) float Returns the cosine of x. func cosh(a float) float Returns the hyperbolic cosine of x. func exp(a float) float Returns e^x, where x is the argument, and e is Euler\u0026rsquo;s number (2.718…, the base of the natural logarithm). func expm1(a float) float Returns subtracting 1 from exp(x). func floor(a float) float Returns the largest integer less than or equal to x. func frac(a float) float Returns the fractional or decimal part of a float value. func hypot(a float, b float) float Returns the square root of the sum of squares of its arguments. func isInt(a float) bool Returns true if the float has no fractional part, otherwise false. func isNaN(a float) bool Returns whether x is not a number. func ln(a float) float Returns the natural logarithm (㏒e; also, ㏑) of x. func log(a float, b float) float Returns the logarithm of y with base x. func log10(a float) float Returns the base-10 logarithm of x. func log1p(a float) float Returns the natural logarithm (㏒e; also ㏑) of 1 + x for the number x. func log2(a float) float Returns the base-2 logarithm of x. func max(a float, b float) float Returns the largest of two numbers. func min(a float, b float) float Returns the smallest of two numbers. func mul32(a float, b float) float Returns the result of the 32-bit integer multiplication of x and y. Integer overflow is allowed. func pow(a float, b float) float Returns base x to the exponent power y (that is, x^y). func random() float Returns a pseudo-random number between 0 and 1. func round(a float) float Returns the value of the number x rounded to the nearest integer. func sign(a float) float Returns the sign of the x, indicating whether x is positive, negative, or zero. func sin(a float) float Returns the sine of x. func sinh(a float) float Returns the hyperbolic sine of x. func sqrt(a float) float Returns the positive square root of x. func tan(a float) float Returns the tangent of x. func tanh(a float) float Returns the hyperbolic tangent of x. func trunc(a float) float Returns the integer portion of x, removing any fractional digits. Std Modules. # Std modules come with Cyber\u0026rsquo;s CLI. They include:\nos: System level functions. test: Utilities for testing. os. # Cyber\u0026rsquo;s os module contains system level functions. It\u0026rsquo;s still undecided as to how much should be included here so it\u0026rsquo;s incomplete. You can still access os and libc functions yourself using Cyber\u0026rsquo;s FFI or embedding API.\nSample usage:\nimport os var map = os.getEnvAll() for map each [k, v]: print \u0026#39;$(k) -\u0026gt; $(v)\u0026#39; var cpu string The current cpu arch\u0026rsquo;s tag name. var endian symbol The current arch\u0026rsquo;s endianness: .little, .big var stderr any Standard error file descriptor. var stdin any Standard input file descriptor. var stdout any Standard output file descriptor. var system string The current operating system\u0026rsquo;s tag name. var vecBitSize int Default SIMD vector bit size. func access(path string, mode symbol) any Attempts to access a file at the given path with the .read, .write, or .readWrite mode. Return true or an error. func args() List Returns the command line arguments in a List. Each argument is validated and returned as a UTF-8 string or array if the validation failed. func bindLib(path any, decls List) any Calls bindLib(path, decls, [:]). func bindLib(path any, decls List, config Map) any Creates an FFI binding to a dynamic library and it\u0026rsquo;s symbols. By default, an anonymous object is returned with the C-functions binded as the object\u0026rsquo;s methods. If config contains genMap: true, a Map is returned instead with C-functions binded as function values. func cacheUrl(url string) any Returns the path of a locally cached file of url. If no such file exists locally, it\u0026rsquo;s fetched from url. func copyFile(srcPath string, dstPath string) none Copies a file to a destination path. func createDir(path string) none Creates the directory at path. Returns true if successful. func createFile(path string, truncate bool) File Creates and opens the file at path. If truncate is true, an existing file will be truncated. func cstr(s any) pointer Returns a null terminated C string. func cwd() string Returns the current working directory. func dirName(path string) any Returns the given path with its last component removed. func execCmd(args List) any Runs a shell command and returns the stdout/stderr. func exePath() string Returns the current executable\u0026rsquo;s path. func exit(status int) none Exits the program with a status code. func fetchUrl(url any) any Fetches the contents at url using the HTTP GET request method. func free(ptr pointer) none Frees the memory located at ptr. func fromCstr(ptr pointer) array Returns an array from a null terminated C string. func getEnv(key string) any Returns an environment value by key. func getEnvAll() Map Returns all environment entries as a Map. func getAllInput() string Reads stdin to the EOF as a string. func getInput() string Reads stdin until a new line as a string. This is intended to read user input from the command line. For bulk reads from stdin, use os.stdin. func malloc(size int) pointer Allocates size bytes of memory and returns a pointer. func milliTime() float Return the calendar timestamp, in milliseconds, relative to UTC 1970-01-01. func openDir(path string) any Invokes openDir(path, false). func openDir(path string, iterable bool) Dir Opens a directory at the given path. iterable indicates that the directory\u0026rsquo;s entries can be iterated. func openFile(path string, mode symbol) File Opens a file at the given path with the .read, .write, or .readWrite mode. func parseArgs(options List) Map Given expected ArgOptions, returns a map of the options and a rest entry which contains the non-option arguments. | func readFile(path string) string Reads the file contents from path with UTF-8 encoding. func realPath(path string) any Returns the absolute path of the given path. func removeDir(path string) none Removes an empty directory at path. Returns true if successful. func removeFile(path string) none Removes the file at path. Returns true if successful. func setEnv(key string, val string) none Sets an environment value by key. func sleep(ms float) none Pauses the current thread for given milliseconds. func unsetEnv(key string) none Removes an environment value by key. func writeFile(path string, contents any) none Writes a string value to a file. type File # func close() none Closes the file handle. File ops invoked afterwards will return error.Closed. func iterator() any func next() any func read(n int) any Reads at most n bytes as an array. n must be at least 1. A result with length 0 indicates the end of file was reached. func readToEnd() any Reads to the end of the file and returns the content as an array. func seek(n int) any Seeks the read/write position to pos bytes from the start. Negative pos is invalid. func seekFromCur(n int) any Seeks the read/write position by pos bytes from the current position. func seekFromEnd(n int) any Seeks the read/write position by pos bytes from the end. Positive pos is invalid. func stat() any Returns info about the file as a Map. func streamLines() any Equivalent to streamLines(4096). func streamLines(bufSize int) any Returns an iterable that streams lines ending in \\n, \\r, \\r\\n, or the EOF. The lines returned include the new line character(s). A buffer size of bufSize bytes is allocated for reading. If \\r is found at the end of the read buffer, the line is returned instead of waiting to see if the next read has a connecting \\n. func write(val any) any Writes a string or array at the current file position. The number of bytes written is returned. type Dir # func iterator() any Returns a new iterator over the directory entries. If this directory was not opened with the iterable flag, error.NotAllowed is returned instead. func stat() any Returns info about the file as a Map. func walk() any Returns a new iterator over the directory recursive entries. If this directory was not opened with the iterable flag, error.NotAllowed is returned instead. type DirIterator # func next() any type CFunc # type CStruct # type CArray # map DirEntry # Entry Summary 'name' -\u0026gt; rawstring The name of the file or directory. 'type' -\u0026gt; #file | #dir | #unknown The type of the entry. map DirWalkEntry # Entry Summary 'name' -\u0026gt; rawstring The name of the file or directory. 'path' -\u0026gt; rawstring The path of the file or directory relative to the walker\u0026rsquo;s root directory. 'type' -\u0026gt; #file | #dir | #unknown The type of the entry. map ArgOption # Entry Summary 'name' -\u0026gt; string The name of the option to match excluding the hyphen prefix. eg. -path 'type' -\u0026gt; metatype(string | float | boolean) Parse as given value type. 'default' -\u0026gt; any Optional: Default value if option is missing. none is used if this is not provided. test. # The test module contains utilities for testing.\nSample usage:\nimport t \u0026#39;test\u0026#39; var a = 123 + 321 t.eq(a, 444) func eq(a any, b any) any Returns whether two values are equal. Panics with error.AssertError if types or values do not match up. func eqList(a any, b any) any Returns true if two lists have the same size and the elements are equal as if eq was called on those corresponding elements. func eqNear(a any, b any) any Returns two numbers are near each other within epsilon 1e-5. func fail() any "},{"id":5,"href":"/cyber/docs/toc/ffi/","title":"FFI","section":"Table of Contents","content":" FFI. # Cyber supports binding to an existing C ABI compatible library at runtime. This allows you to call into dynamic libraries created in C or other languages. Cyber uses libtcc to JIT compile the bindings so function calls are fast. bindLib is part of the os module and accepts the path to the library as a string and a list of CFunc or CStruct declarations.\nimport os var lib = os.bindLib(\u0026#39;mylib.so\u0026#39;, [ [os.CFunc sym: \u0026#39;add\u0026#39;, args: [.int, .int], ret: .int] ]) lib.add(123, 321) If the path argument to bindLib is just a filename, the search steps for the library is specific to the operating system. Provide an absolute (eg. \u0026lsquo;/foo/mylib.so\u0026rsquo;) or relative (eg. \u0026lsquo;./mylib.so\u0026rsquo;) path to load from a direct location instead. When the path argument is none, it loads the currently running executable as a library allowing you to bind exported functions from the Cyber CLI or your own embedded Cyber app/runtime.\nWhen using CFunc or CStruct declarations, symbols are used to represent default type mappings from Cyber to C and back:\nIncomplete: This is not the final API for dynamically loading and interfacing with C libraries. The plan is to parse a subset of C headers to bind to Cyber types and functions.\nBinding Cyber C Details .bool bool bool .char int int8_t, signed char .uchar int uint8_t, unsigned char .short int int16_t, short .ushort int uint16_t, unsigned short .int int int32_t, int .uint int uint32_t, unsigned int .long int int64_t, long long .ulong int uint64_t, unsigned long long .usize int size_t, uintptr_t .float float float .double float double .charPtr pointer char* Use os.cstr() and os.fromCstr() to convert between a Cyber string and a null terminated C string. .voidPtr pointer void* sym symbol object \u0026lt;sym\u0026gt; Struct The mapping from a Cyber object type sym and the C-struct can be declared with CStruct. By default bindLib returns an anonymous object with the binded C-functions as methods. This is convenient for using it like an object, but it\u0026rsquo;s less optimal compared to binding as functions. If a config is passed into bindLib as the third argument, genMap: true makes bindLib return a map instead with the binded C-functions as Cyber functions. The resulting object of bindLib holds a reference to an internal TCCState which owns the loaded JIT code. Once the object is released by ARC, the TCCState is also released which removes the JIT code from memory.\nCFunc. # The CFunc object lets you bind to a C-function. The sym field maps to the C-function\u0026rsquo;s symbol name in the dynamic library. The args field declares the type mapping from Cyber to C-function\u0026rsquo;s arguments. Finally, the ret field declares the type mapping from the C-function\u0026rsquo;s return type to a Cyber type.\nimport os var lib = os.bindLib(\u0026#39;mylib.so\u0026#39;, [ [os.CFunc sym: \u0026#39;add\u0026#39;, args: [.int, .int], ret: .int] ]) lib.add(123, 321) The example above maps to this C declaration in mylib.so:\nint add(int a, int b) { return a + b; } CStruct. # You can also bind object types to C-structs using the CStruct object. The type field accepts an object type symbol and fields indicates the mapping for each field in type to and from a C-struct. After adding a CStruct declaration, you can use the object type symbol in CFunc args and ret and also other CStruct fields.\nimport os type MyObject object: var a float var b pointer var c bool var lib = os.bindLib(\u0026#39;mylib.so\u0026#39;, [ [os.CFunc sym: \u0026#39;foo\u0026#39;, args: [MyObject], ret: MyObject] [os.CStruct fields: [.double, .charPtr, .bool], type: MyObject] ]) var res = lib.foo([MyObject a: 123.0, b: os.cstr(\u0026#39;foo\u0026#39;), c: true]) The example above maps to these C declarations in mylib.so:\ntypedef struct MyObject { double a; char* b; bool c; } MyObject; MyObject foo(MyObject o) { // Do something. } CStruct also generates ptrTo[Type] as a helper function to dereference an opaque ptr to a new Cyber object:\nimport os var lib = os.bindLib(\u0026#39;mylib.so\u0026#39;, [ [os.CFunc sym: \u0026#39;foo\u0026#39;, args: [MyObject], ret: .voidPtr] [os.CStruct fields: [.double, .charPtr, .bool], type: MyObject] ]) var ptr = lib.foo([MyObject a: 123, b: os.cstr(\u0026#39;foo\u0026#39;), c: true]) var res = lib.ptrToMyObject(ptr) Pointers # A pointer is used to read or write to an exact memory address. This is typically used for FFI to manually map Cyber types to C, and back. See type pointer.\nA new pointer can be created with the builtin pointer.\nvar ptr = pointer(0xDEADBEEF) print ptr.value() --\u0026#39;3735928559\u0026#39; "},{"id":6,"href":"/cyber/docs/toc/errors/","title":"Error Handling","section":"Table of Contents","content":" Error Handling. # Cyber provides a throw/catch mechanism to handle expected errors. For unexpected errors, panics can be used as a fail-fast mechanism to abort the currently running fiber.\nError trait. # Only types that implement the Error trait can be thrown or attached to a panic. Since the Error trait is empty, it\u0026rsquo;s simple to turn any type into a throwable type.\nerror value. # An error value contains a symbol and implements the Error trait. They can be created without a declaration using the error literal:\nvar err = error.Oops Use sym() to obtain the underlying symbol:\nprint err.sym() -- Prints \u0026#34;.Oops\u0026#34; Since error is a primitive value, it can be compared using the == operator.\nif err == error.Oops: handleOops() -- Alternatively. if err.sym() == .Oops: handleOops() Enum error. # By implementing the Error trait, an enum type can be throwable: *Planned Feature\ntype MyError enum: with Error boom badArgument nameTooLong var err = MyError.nameTooLong Throwing errors. # Use the throw keyword to throw errors. A thrown error continues to bubble up the call stack until it is caught by a try block or expression.\nfunc fail(): throw error.Oops -- Throws an error with the symbol `#Oops` func fail2(): throw 123 -- Panic. Can only throw an error -- that implement the `Error` trait. throw can also be used as an expression.\nfunc fail(): var a = false or throw error.False Catching errors. # try block. # The try block catches thrown errors and resumes execution in a followup catch block:\ntry: funcThatCanFail() catch err: print err -- \u0026#39;error.Failed\u0026#39; caught variable. # The contextual caught variable is used to reference the caught error:\ntry: funcThatCanFail() catch: print caught -- \u0026#39;error.Failed\u0026#39; catch matching. # An inner catch block contains a matching clause: *Planned Feature\ntry: funcThatCanFail() catch error.BadDay: eatSnack() catch: print caught Enum errors can be matched: *Planned Feature\ntry: funcThatCanFail() catch MyError.Boom: print \u0026#39;Kaboom!\u0026#39; catch: print caught try expression. # The try expression either returns a non-error result or the default value from the catch clause:\nvar res = try funcThatCanFail() catch 123 print res -- \u0026#39;123\u0026#39; Since errors bubble up automatically, any errors thrown from sub-expressions are also caught:\nvar res = try happyFunc(funcThatCanFail()) catch 123 print res -- \u0026#39;123\u0026#39; Value or error. # When the catch clause is omitted, the try expression will return either the value or the error:\nvar res = try funcThatCanFail() if res == error.Failed: print \u0026#39;Result is an error.\u0026#39; Semantic checks. # throws specifier. # The throws specifier indicates that a function contains a throwing expression that was not caught with try catch.\nWhen a function does not have a return specifier, it\u0026rsquo;s implicitly given the throws specifier:\nfunc foo(): throw error.Failure func bar() throws: throw error.Failure -- `foo` and `bar` both have the same return specifier. Return types for typed functions are declared after throws using a comma separator:\nfunc result(cond bool) throws, int: if cond: return 123 else: throw error.Failure Requiring throws. # A compile-time error is issued when a typed function without a throws specifier contains an uncaught throwing expression: *Planned Feature\nfunc foo(a int) int: if a == 10: throw error.Failure -- CompileError. `foo` requires the `throws` else: -- specifier or any throwing expression must return a * 2 -- be caught with `try catch`. Stack trace. # When an uncaught error bubbles up to the top, its stack trace from the throw callsite is dumped to the console. The builtin errorTrace() and errorReport() are used to obtain the stack trace info.\ntry: funcThatCanFail() catch: -- Prints the stack trace summary of the caught error. print errorReport() -- Provides structured info about the stack trace. var info = errorTrace() print info.frames.len() Unexpected errors. # An unexpected error is an error that is not meant to be handled at runtime.\nPanics. # The builtin panic is used as a fail-fast mechanism to quickly exit the current fiber with an error payload:\nfunc kaboom(): panic(error.danger) kaboom() -- Script ends and prints the stack trace. Panics can not be caught using try catch. Once panic is invoked, the current fiber stops execution and begins to unwind its call stack. Once the error is propagated to the root, the fiber ends and transitions to a panic state. If the main fiber ends this way, the VM begins to shutdown. Otherwise, execution resumes on the next fiber which allows recovery from a panic.\n"},{"id":7,"href":"/cyber/docs/toc/concurrency/","title":"Concurrency","section":"Table of Contents","content":" Concurrency. # Cyber supports fibers as a concurrency mechanism. There are plans to support preemptive concurrency with async/await as well as multithreading.\nFibers. # A fiber represents a separate execution context as a first-class value. It contains it\u0026rsquo;s own call stack and program counter. Fibers by themselves do not enable parallelism.\nCreating fibers. # The coinit keyword creates and returns a new fiber using a function as the entry point:\nvar count = 0 var foo = func (): count += 1 coyield count += 1 var fiber = coinit(foo) print count -- \u0026#39;0\u0026#39; coresume fiber print count -- \u0026#39;1\u0026#39; coresume fiber print count -- \u0026#39;2\u0026#39; A fiber does not start execution until coresume is invoked on it. coyield pauses the current fiber and execution is returned to the previous fiber that invoked coresume.\nPassing arguments. # Arguments after the callee are passed into the entry function:\nvar count = 0 var increment = func (inc): count += inc var create = coinit(increment, 5) coresume fiber print count -- \u0026#39;5\u0026#39; When the fiber is created, the arguments are saved inside the fiber\u0026rsquo;s stack. Once the first coresume is invoked, the entry function is invoked with the saved arguments.\nReset state. # To reset a fiber to its initial state, invoke reset(). *Planned Feature When reset, the existing stack is unwinded, the program counter returns to the starting point, and the state is set to .init:\nfunc fib(n int) int: coyield n if n \u0026lt; 2: return n return fib(n - 1) + fib(n - 2) var task = coinit(fib, 10) -- Progress the fiber... print(coresume task) -- Prints \u0026#34;10\u0026#34; print(coresume task) -- Prints \u0026#34;9\u0026#34; print(coresume task) -- Prints \u0026#34;8\u0026#34; -- Reset back to the start with the `.init` state. fiber.reset() print(coresume task) -- Prints \u0026#34;10\u0026#34; Rebinding arguments. # Arguments attached to the fiber can be rebinded with a different set of values. *Planned Feature This allows fiber reuse, instead of creating a new fiber:\nvar task = coinit(fib, 10) -- Run task to completion. var res = 0 while fiber.status() != .done: res = coresume fiber print res fiber.reset() fiber.bindArgs(20) -- Run task again with the new argument... Fiber block. # A fiber block is used to construct a fiber without an entry function. *Planned Feature The counting example can be rewritten to:\nvar count = 0 var fiber = coinit: count += 1 -- `count is captured` coyield count += 1 print count -- \u0026#39;0\u0026#39; coresume fiber print count -- \u0026#39;1\u0026#39; coresume fiber print count -- \u0026#39;2\u0026#39; Referencing parent variables from the fiber block automatically captures them just like a function closure.\nPause and resume. # coyield can be used anywhere in a fiber\u0026rsquo;s call stack to pause execution and return to the previous fiber.\nfunc foo(): print \u0026#39;foo\u0026#39; bar() func bar(): -- Nested coyield in call stack. coyield print \u0026#39;bar\u0026#39; var fiber = coinit foo() coresume fiber coresume also returns the resulting value.\nfunc foo(): return 123 var fiber = coinit(foo) print(coresume fiber) -- \u0026#39;123\u0026#39; coyield can return a value back to coresume. *Planned Feature\nFiber state. # Use Fiber.status() to get the current state of the fiber.\nfunc foo(): coyield print \u0026#39;done\u0026#39; var fiber = coinit(foo) print fiber.status() -- \u0026#39;.paused\u0026#39; coresume fiber print fiber.status() -- \u0026#39;.paused\u0026#39; coresume fiber print fiber.status() -- \u0026#39;.done\u0026#39; The main execution context is a fiber as well. Once the main fiber has finished, the VM is done and control is returned to the host.\nGas mileage. # Planned Feature\nAsync. # Planned Feature\nMulti-thread. # Planned Feature\n"},{"id":8,"href":"/cyber/docs/toc/type-system/","title":"Type System","section":"Table of Contents","content":" Type System. # Cyber supports the use of both dynamically and statically typed code.\nDynamic typing. # Dynamic typing can reduce the amount of friction when writing code, but it can also result in more runtime errors.\nmy declaration. # Variables declared with my are assigned the dynamic type:\nmy a = 123 dynamic vs any # dynamic values can be freely used and copied without any compile errors (if there is a chance it can succeed at runtime, see Recent type inference):\nmy a = 123 func getFirstRune(s string): return s[0] getFirstRune(a) -- RuntimeError. Expected `string`. Since a is dynamic, passing it to a typed function parameter is allowed at compile-time, but will fail when the function is invoked at runtime.\nThe any type on the otherhand is a static type and must be explicitly declared using var:\nvar a any = 123 func getFirstRune(s string): return s[0] getFirstRune(a) -- CompileError. Expected `string`. This same setup will now fail at compile-time because any does not satisfy the destination\u0026rsquo;s string type constraint.\nThe use of the dynamic type effectively defers type checking to runtime while any is a static type and must adhere to type constraints at compile-time.\nA dynamic value can be used in any operation. It can be invoked as the callee, invoked as the receiver of a method call, or used with operators.\nInvoking dynamic values. # When a dynamic value is invoked, checks on whether the callee is a function is deferred to runtime.\nmy op = 123 print op(1, 2, 3) -- RuntimeError. Expected a function. Dynamic return value. # When the return type of a function is not specified, it defaults to the dynamic type. This allows copying the return value to a typed destination without casting:\nfunc getValue(): return 123 func add(a int, b int): return a + b print add(getValue(), 2) -- Prints \u0026#34;125\u0026#34; The add function defers type checking of getValue() to runtime because it has the dynamic type.\nRecent type inference. # Although a dynamic variable has the most flexibility, in some situations it is advantageous to know what type it could be.\nThe compiler keeps a running record of a dynamic variable\u0026rsquo;s most recent type to gain additional compile-time features without sacrificing flexibility. It can prevent inevitable runtime errors and avoid unnecessary type casts.\nWhen a dynamic variable is first initialized, it has a recent type inferred from its initializer. In the following, a has the recent type of int at compile-time because numeric literals default to the int type:\nmy a = 123 The recent type can change at compile-time from another assignment. If a is then assigned to a string literal, a from that point on has the recent type of string at compile-time:\nmy a = 123 foo(a) -- Valid call expression. a = \u0026#39;hello\u0026#39; foo(a) -- CompileError. Expected `int` argument, got `string`. func foo(n int): pass Even though a is dynamic and is usually allowed to defer type checking to runtime, the compiler knows that doing so in this context would always result in a runtime error, so it provides a compile error instead. This provides a quicker feedback to fix the problem.\nThe recent type of a can also change in branches. However, after the branch block, a will have a recent type after merging the types assigned to a from the two branched code paths. Currently, the any type is used if the types from the two branches differ. At the end of the following if block, a has the recent type of any type after merging the int and string types:\nmy a = 123 if a \u0026gt; 20: a = \u0026#39;hello\u0026#39; foo(a) -- Valid call expression. `foo` can be called without type casting. foo(a) -- CompileError. Expected `string` argument, got `any`. func foo(s string): pass Static typing. # Static typing can be incrementally applied which provides compile-time guarantees and prevents runtime errors. Static typing also makes it easier to maintain and refactor your code.\nIncomplete: There are some cases where calling static functions with dynamic values doesn\u0026rsquo;t do a runtime type check.\nBuiltin types. # The following builtin types are available in every module: bool, float, int, string, List, Map, error, fiber, any.\nvar declaration. # A var declaration automatically infers the type from the initializer:\n-- Initialized as an `int` variable. var a = 123 var declarations are strictly for static typing. If the assigned value\u0026rsquo;s type is dynamic, the variable\u0026rsquo;s type becomes any.\nfunc getValue(): return [\u0026#39;a\u0026#39;, \u0026#39;list\u0026#39;] -- Initialized as an `any` variable. var a = getValue() Typed variables. # A typed local variable can be declared by attaching a type specifier after its name. The value assigned to the variable must satisfy the type constraint or a compile error is issued.\nvar a float = 123 var b int = 123.0 -- CompileError. Expected `int`, got `float`. Any operation afterwards that violates the type constraint of the variable will result in a compile error.\na = \u0026#39;hello\u0026#39; -- CompileError. Expected `float`, got `string`. Type specifiers must be resolved at compile-time.\nvar foo Foo = none -- CompileError. Type `Foo` is not declared. Static variables are declared in a similar way:\nvar Root.global Map = [:] Object types. # A type object declaration creates a new object type. Field types are optional and declared with a type specifier after their name.\ntype Student object: -- Creates a new type named `Student` var name string var age int var gpa float Instantiating a new object does not require typed fields to be initialized. Missing field values will default to their zero value:\nvar s = [Student:] print s.name -- Prints \u0026#34;\u0026#34; print s.age -- Prints \u0026#34;0\u0026#34; print s.gpa -- Prints \u0026#34;0.0\u0026#34; Circular type dependencies are allowed if the object can be initialized:\nPlanned Feature: Optional types are not currently supported.\ntype Node object: var val any var next Node? -- Valid type specifier. In this example, next has an optional Node? type so it can be initialized to none when creating a new Node object.\nThe following example will fail because this version of Node can not be initialized:\ntype Node object: var val any var next Node var n = [Node:] -- CompileError. Can not zero initialize `next` -- because of circular dependency. Zero values. # The following shows the zero values of builtin or created types.\nType Zero value boolean false int 0 float 0.0 string '' rawstring '' List [] Map [:] type S object [S:] @host type S object S.$zero() dynamic none any none S? none Type aliases. # A type alias is declared from a single line type statement. This creates a new type symbol for an existing data type.\nimport util \u0026#39;./util.cy\u0026#39; type Vec3 util.Vec3 var v = [Vec3 x: 3, y: 4, z: 5] Functions. # Function parameter and return type specifiers follows a similiar syntax.\nfunc mul(a float, b float) float: return a * b print mul(3, 4) print mul(3, \u0026#39;4\u0026#39;) -- CompileError. Function signature mismatch. Traits. # Planned Feature\nUnion types. # Planned Feature\nany type. # A variable with the any type can hold any value, but copying it to narrowed type destination will result in a compile error:\nfunc square(i int): return i * i var a any = 123 a = [\u0026#39;a\u0026#39;, \u0026#39;list\u0026#39;] -- Valid assignment to a value with a different type. a = 10 print square(a) -- CompileError. Expected `int`, got `any`. a must be explicitly casted to satisfy the type constraint:\nprint square(a as int) -- Prints \u0026#34;100\u0026#34;. Invoking any values. # Since any is a static type, invoking an any value must be explicitly casted to the appropriate function type.\nPlanned Feature: Casting to a function type is not currently supported.\nfunc add(a int, b int) int: return a + b var op any = add print op(1, 2) -- CompileError. Expected `func (int, int) any` var opFunc = op as (func (int, int) int) print opFunc(1, 2) -- Prints \u0026#34;3\u0026#34;. Type casting. # The as keyword can be used to cast a value to a specific type. Casting lets the compiler know what the expected type is and does not perform any conversions.\nIf the compiler knows the cast will always fail at runtime, a compile error is returned instead.\nprint(\u0026#39;123\u0026#39; as int) -- CompileError. Can not cast `string` to `int`. If the cast fails at runtime, a panic is returned.\nvar erased any = 123 add(1, erased as int) -- Success. print(erased as string) -- Panic. Can not cast `int` to `string`. func add(a int, b int): return a + b "},{"id":9,"href":"/cyber/docs/toc/metaprogramming/","title":"Metaprogramming","section":"Table of Contents","content":" Metaprogramming. # Operator overloading. # All operators are implemented as object methods.\nIncomplete: Not all operators have transitioned to the method paradigm.\nNormally this would impact performance, but Cyber generates specialized bytecode for builtin types like int and float. The VM performs inline caching at runtime to eliminate the overhead of evaluating on dynamic operands.\nTo overload an operator for an object type, declare $prefix, $infix, $postfix methods. See the available builtin operators. Since operator names aren\u0026rsquo;t allowed as standard identifiers, they are contained in a string literal.\ntype Vec2 object: var x float var y float func \u0026#39;$infix+\u0026#39;(o): return [Vec2 x: x + o.x, y: y + o.y, ] func \u0026#39;$prefix-\u0026#39;(): return [Vec2 x: -x, y: -y] var a = [Vec2 x: 1, y: 2] var b = a + [Vec2 x: 3, y: 4] var c = -a Some special operators have their own name. This example overloads the index operator and the set index operator:\ntype MyCollection object: var arr List func \u0026#39;$index\u0026#39;(idx): return arr[idx * 2] func \u0026#39;$setIndex\u0026#39;(idx, val): arr[idx * 2] = val var a = [MyCollection arr: [1, 2, 3, 4]] print a[1] -- Prints `3` Builtin operators. # A list of all supported operators:\nOperator Name Bitwise not $prefix~ Minus $prefix- Greater $infix\u0026gt; Greater equal $infix\u0026gt;= Less $infix\u0026lt; Less equal $infix\u0026lt;= Add $infix+ Subtract $infix- Multiply $infix* Divide $infix/ Modulus $infix% Power $infix^ Bitwise and $infix\u0026amp; Bitwise or $infix| Bitwise xor $infix|| Bitwise left shift $infix\u0026lt;\u0026lt; Bitwise right shift $infix\u0026gt;\u0026gt; Index $index Set index $setIndex Slice $slice Custom operators. # Planned Feature\nMagic functions. # Call module. # Declare a $call function to allow invoking a module as a function.\nIncomplete: Although $call function is supported in the VM and builtin modules use it, it is not currently enabled for user modules.\n-- Object types are also modules. type Vec2 object: var x float var y float func \u0026#39;$call\u0026#39;(x float, y float) Vec2: return [Vec2 x: x, y: y] var v = Vec2(1, 2) Getter/Setter. # Planned Feature\nMissing method. # Declare a $missing method as a fallback when a method was not found in an instance.\nPlanned Feature\ntype A object: func \u0026#39;$missing\u0026#39;(args...): return args.len var a = [A:] print a.foo() -- Output: \u0026#39;0\u0026#39; print a.bar(1, 2) -- Output: \u0026#39;2\u0026#39; Reflection. # A metatype object references an internal type. Use the typeof builtin to get the metatype of a value.\nvar val = 123 print typeof(val) -- \u0026#39;type: float\u0026#39; -- Referencing a type as a value also returns its `metatype`. print bool -- \u0026#39;type: bool\u0026#39; Annotations. # Annotations are used to attach modifiers to declarative statements. The @host annotation is used for embedding to bind a host function to a Cyber function:\n@host func compute() float Custom annotations.\nPlanned Feature\nRuntime eval. # Planned Feature\nGenerics. # Planned Feature\nCompile-time. # Planned Feature\n"},{"id":10,"href":"/cyber/docs/toc/embedding/","title":"Embedding","section":"Table of Contents","content":" Embedding. # Planned Feature\n"},{"id":11,"href":"/cyber/docs/toc/memory/","title":"Memory","section":"Table of Contents","content":" Memory. # Cyber provides memory safety by default.\nARC. # Cyber uses ARC or automatic reference counting to manage memory. ARC is deterministic and has less overhead compared to a tracing garbage collector. Reference counting distributes memory management, which reduces GC pauses and makes ARC suitable for realtime applications. One common issue in ARC implementations is reference cycles which Cyber addresses with Weak References and it\u0026rsquo;s very own Cycle Detection.\nReference Counting. # In Cyber, there are primitive and object values. Primitives don\u0026rsquo;t need any memory management, since they are copied by value and no heap allocation is required (with the exception of primitives being captured by a closure).\nObjects are managed by ARC. Each object has its own reference counter. Upon creating a new object, it receives a reference count of 1. When the object is copied, it\u0026rsquo;s retained and the reference count increments by 1. When an object value is removed from it\u0026rsquo;s parent or is no longer reachable in the current stack frame, it is released and the reference count decrements by 1.\nOnce the reference count reaches 0 the object begins its destruction procedure. First, child references are released thereby decrementing their reference counts by 1. If the object is a host object, it will invoke its finalizer function. Afterwards, the object is freed from memory.\nOptimizations. # The compiler can reduce the number of retain/release ops since it can infer value types even though they are dynamically typed to the user. Arguments passed to functions are only retained depending on the analysis from the callsite.\nClosures. # When primitive variables are captured by a closure, they are boxed and allocated on the heap. This means they are managed by ARC and cleaned up when there are no more references to them.\nFibers. # Fibers are freed by ARC just like any other object. Once there are no references to the fiber, it begins to release it\u0026rsquo;s child references by unwinding it\u0026rsquo;s call stack.\nHeap. # Many object types in Cyber are small enough to be at or under 40 bytes. To take advantage of this, Cyber can reserve object pools to quickly allocate and free these small objects with very little bookkeeping. Bigger objects are allocated and managed by mimalloc which has proven to be a fast and reliable general-purpose heap allocator.\nWeak References. # Planned Feature\nCycle Detection. # The cycle detector is also considered a GC and frees abandoned objects managed by ARC. Although weak references can remove cycles altogether, Cyber does not force you to use them and provides a manual GC as a one-time catch all solution.\nIncomplete Feature: Only the main fiber stack is cleaned up at the moment.\nTo invoke the GC, call the builtin function: performGC.\nfunc foo(): -- Create a reference cycle. var a = [] var b = [] a.append(b) b.append(a) -- Cycle still alive in the current stack so no cleanup is done. var res = performGC() print res[\u0026#39;numCycFreed\u0026#39;] -- Output: 0 print res[\u0026#39;numObjFreed\u0026#39;] -- Output: 0 foo() -- `a` and `b` are no longer reachable, so the GC does work. var res = performGC() print res[\u0026#39;numCycFreed\u0026#39;] -- Output: 2 print res[\u0026#39;numObjFreed\u0026#39;] -- Output: 2 "},{"id":12,"href":"/cyber/docs/toc/aot-jit/","title":"AOT/JIT","section":"Table of Contents","content":" AOT and JIT # Planned Feature\n"}]