<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Data Types. # In Cyber, there are primitive types and object types. Primitives are copied around by value and don&rsquo;t need additional heap memory or reference counts.
Primitives include Booleans, Floats, Integers, Enums, Symbols, Error Symbols, and the none value.
Object types include Lists, Tuples, Maps, Strings, Arrays, User Objects, Lambdas, Fibers, Enums with payloads, Pointers, and several internal object types.
None. # The none value represents an empty value."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="Data Types"><meta property="og:description" content="Data Types. # In Cyber, there are primitive types and object types. Primitives are copied around by value and don&rsquo;t need additional heap memory or reference counts.
Primitives include Booleans, Floats, Integers, Enums, Symbols, Error Symbols, and the none value.
Object types include Lists, Tuples, Maps, Strings, Arrays, User Objects, Lambdas, Fibers, Enums with payloads, Pointers, and several internal object types.
None. # The none value represents an empty value."><meta property="og:type" content="article"><meta property="og:url" content="https://fubark.github.io/cyber/docs/toc/data-types/"><meta property="article:section" content="docs"><title>Data Types | Cyber Docs v0.2</title>
<link rel=manifest href=/cyber/manifest.json><link rel=icon href=/cyber/favicon.png><link rel=stylesheet href=/cyber/book.min.4f0117e74e5337280f18eb9641eae520cb4b25adcf5dd64fafad4664145a5957.css integrity="sha256-TwEX505TNygPGOuWQerlIMtLJa3PXdZPr61GZBRaWVc=" crossorigin=anonymous><script defer src=/cyber/flexsearch.min.js></script><script defer src=/cyber/en.search.min.c97b7e9d6d7ecdde305d5ebc7d07e2caf6b0d6e43c2fd47e02abf0ada4934c54.js integrity="sha256-yXt+nW1+zd4wXV68fQfiyvaw1uQ8L9R+AqvwraSTTFQ=" crossorigin=anonymous></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel=stylesheet><link rel=stylesheet href=/cyber/hljs.min.css><link rel=stylesheet href=/cyber/style.css></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/cyber/><span>Cyber Docs v0.2</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://cyberscript.dev target=_blank rel=noopener>Homepage</a></li><li><a href=https://cyberscript.dev/play.html target=_blank rel=noopener>Playground</a></li></ul><ul><li class=book-section-flat><span>Table of Contents</span><ul><li><a href=/cyber/docs/toc/syntax/>Syntax</a></li><li><a href=/cyber/docs/toc/data-types/ class=active>Data Types</a></li><li><a href=/cyber/docs/toc/control-flow/>Control Flow</a></li><li><a href=/cyber/docs/toc/functions/>Functions</a></li><li><a href=/cyber/docs/toc/modules/>Modules</a></li><li><a href=/cyber/docs/toc/ffi/>FFI</a></li><li><a href=/cyber/docs/toc/errors/>Error Handling</a></li><li><a href=/cyber/docs/toc/concurrency/>Concurrency</a></li><li><a href=/cyber/docs/toc/type-system/>Type System</a></li><li><a href=/cyber/docs/toc/metaprogramming/>Metaprogramming</a></li><li><a href=/cyber/docs/toc/embedding/>Embedding</a></li><li><a href=/cyber/docs/toc/memory/>Memory</a></li><li><a href=/cyber/docs/toc/aot-jit/>AOT/JIT</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/cyber/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Data Types</strong>
<label for=toc-control><img src=/cyber/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#none>None.</a></li><li><a href=#booleans>Booleans.</a></li><li><a href=#numbers>Numbers.</a><ul><li><a href=#integers>Integers.</a></li><li><a href=#floats>Floats.</a></li><li><a href=#big-numbers>Big Numbers.</a></li></ul></li><li><a href=#strings>Strings.</a><ul><li><a href=#string-interpolation>String Interpolation.</a></li></ul></li><li><a href=#arrays>Arrays.</a></li><li><a href=#bracket-literals>Bracket literals.</a></li><li><a href=#lists>Lists.</a></li><li><a href=#tuples>Tuples.</a></li><li><a href=#maps>Maps.</a><ul><li><a href=#create-map>Create map.</a></li><li><a href=#empty-map>Empty map.</a></li><li><a href=#map-indexing>Map indexing.</a></li><li><a href=#map-operations>Map operations.</a></li><li><a href=#map-block>Map block.</a></li></ul></li><li><a href=#objects>Objects.</a><ul><li><a href=#fields>Fields.</a></li><li><a href=#instantiation>Instantiation.</a></li><li><a href=#methods>Methods.</a></li><li><a href=#self-variable><code>self</code> variable.</a></li><li><a href=#type-functions>Type functions.</a></li><li><a href=#type-variables>Type variables.</a></li></ul></li><li><a href=#enums>Enums.</a></li><li><a href=#symbols>Symbols.</a></li></ul></nav></aside></header><article class=markdown><h1 id=data-types>Data Types.
<a class=anchor href=#data-types>#</a></h1><p>In Cyber, there are primitive types and object types. Primitives are copied around by value and don&rsquo;t need additional heap memory or reference counts.</p><p>Primitives include <a href=#booleans>Booleans</a>, <a href=#floats>Floats</a>, <a href=#integers>Integers</a>, <a href=#enums>Enums</a>, <a href=#symbols>Symbols</a>, <a href=/cyber/docs/toc/errors/>Error Symbols</a>, and the <code>none</code> value.</p><p>Object types include <a href=#lists>Lists</a>, <a href=#tuples>Tuples</a>, <a href=#maps>Maps</a>, <a href=#strings>Strings</a>, <a href=#arrays>Arrays</a>, <a href=#objects>User Objects</a>, <a href=/cyber/docs/toc/functions/#lambdas>Lambdas</a>, <a href=/cyber/docs/toc/concurrency/#fibers>Fibers</a>, <a href=#enums>Enums with payloads</a>, <a href=/cyber/docs/toc/ffi/#pointers>Pointers</a>, and several internal object types.</p><h2 id=none>None.
<a class=anchor href=#none>#</a></h2><p>The <code>none</code> value represents an empty value. This is similar to null in other languages.</p><h2 id=booleans>Booleans.
<a class=anchor href=#booleans>#</a></h2><p>Booleans can be <code>true</code> or <code>false</code>. See <a href=/cyber/docs/toc/modules/#type-bool><code>type bool</code></a>.</p><pre tabindex=0><code class=language-cy data-lang=cy>var a = true
if a:
    print &#39;a is true&#39;
</code></pre><p>When other value types are coerced to the bool type, the truthy value is determined as follows.</p><ul><li>The <code>none</code> value is <code>false</code>.</li><li>Other objects and values are always <code>true</code>.</li></ul><h2 id=numbers>Numbers.
<a class=anchor href=#numbers>#</a></h2><h3 id=integers>Integers.
<a class=anchor href=#integers>#</a></h3><p><code>int</code> is the default integer type. It has 48-bits and can represent integers in the range -(2<sup>47</sup>) to 2<sup>47</sup>-1. See <a href=/cyber/docs/toc/modules/#type-int><code>type int</code></a>.</p><p>When a numeric literal is used and the type can not be inferred, it will default to the <code>int</code> type:</p><pre tabindex=0><code class=language-cy data-lang=cy>var a = 123
</code></pre><p>Integer notations always produce a <code>int</code> value:</p><pre tabindex=0><code class=language-cy data-lang=cy>var a = 0xFF     -- hex.
a = 0o17         -- octal.
a = 0b1010       -- binary.
a = 0u&#39;üê∂&#39;       -- UTF-8 rune.
</code></pre><p>Arbitrary values can be converted to a <code>int</code> using the type as a function.</p><pre tabindex=0><code class=language-cy data-lang=cy>var a = &#39;123&#39;
var b = int(a) 
</code></pre><p>In addition to arithmetic operations, integers can also perform <a href=/cyber/docs/toc/syntax/#bitwise-operators>bitwise operations</a>.</p><h3 id=floats>Floats.
<a class=anchor href=#floats>#</a></h3><p><code>float</code> is the default floating point type. It has a (IEEE 754) 64-bit floating point format. See <a href=/cyber/docs/toc/modules/#type-float><code>type float</code></a>.</p><p>Although a <code>float</code> represents a decimal number, it can also represent integers between -(2<sup>53</sup>-1) and (2<sup>53</sup>-1). Any integers beyond the safe integer range is not guaranteed to have a unique representation.</p><p>A numeric literal can be used to create a <code>float</code> if the inferred type is a <code>float</code>:</p><pre tabindex=0><code class=language-cy data-lang=cy>var a float = 123
</code></pre><p>Decimal and scientific notations always produce a <code>float</code> value:</p><pre tabindex=0><code class=language-cy data-lang=cy>var a = 2.34567
var b = 123.0e4
</code></pre><p>Arbitrary values can be converted to a <code>float</code> using the type as a function.</p><pre tabindex=0><code class=language-cy data-lang=cy>var a = &#39;12.3&#39;
var b = float(a) 
</code></pre><h3 id=big-numbers>Big Numbers.
<a class=anchor href=#big-numbers>#</a></h3><blockquote><p><em>Planned Feature</em></p></blockquote><h2 id=strings>Strings.
<a class=anchor href=#strings>#</a></h2><p>The <code>string</code> type represents a sequence of UTF-8 codepoints, also known as <code>runes</code>. Each rune is stored internally as 1-4 bytes and can be represented as an <code>int</code>. See <a href=/cyber/docs/toc/modules/#type-string-trait><code>type string</code></a>.</p><p>Under the hood, there are multiple string implementations to make operations faster by default.</p><p>Strings are <strong>immutable</strong>, so operations that do string manipulation return a new string. By default, small strings are interned to reduce memory footprint.</p><p>To mutate an existing string, use <a href=#mutstring>MutString</a>. <span class=todo>*Planned Feature</span></p><p>A string is always UTF-8 validated. Using an <a href=#array>Array</a> to represent raw bytes of a string is faster but you&rsquo;ll have to validate them and take care of indexing.</p><p>A single line string literal is surrounded in single quotes.</p><pre tabindex=0><code class=language-cy data-lang=cy>var apple = &#39;a fruit&#39;
</code></pre><p>You can escape the single quote inside the literal or use double quotes.</p><pre tabindex=0><code class=language-cy data-lang=cy>var apple = &#39;Bob\&#39;s fruit&#39;
apple = &#34;Bob&#39;s fruit&#34;
</code></pre><p>Concatenate two strings together with the <code>+</code> operator or the method <code>concat</code>.</p><pre tabindex=0><code class=language-cy data-lang=cy>var res = &#39;abc&#39; + &#39;xyz&#39;
res = res.concat(&#39;end&#39;)
</code></pre><p>Strings are UTF-8 encoded.</p><pre tabindex=0><code class=language-cy data-lang=cy>var str = &#39;abcü¶äxyzüê∂&#39;
</code></pre><p>Use double quotes to surround a multi-line string.</p><pre tabindex=0><code class=language-cy data-lang=cy>var str = &#34;line a
line b
line c&#34;
</code></pre><p>You can escape double quotes inside the literal or use triple quotes.</p><pre tabindex=0><code class=language-cy data-lang=cy>var str = &#34;line a
line \&#34;b\&#34;
line c&#34;

-- Using triple quotes.
str = &#39;&#39;&#39;line a
line &#34;b&#34;
line c
&#39;&#39;&#39;
</code></pre><p>The following escape sequences are supported:</p><table><thead><tr><th>Escape Sequence</th><th>Code</th><th>Description</th></tr></thead><tbody><tr><td>\a</td><td>0x07</td><td>Terminal bell.</td></tr><tr><td>\b</td><td>0x08</td><td>Backspace.</td></tr><tr><td>\e</td><td>0x1b</td><td>Escape character.</td></tr><tr><td>\n</td><td>0x0a</td><td>Line feed character.</td></tr><tr><td>\r</td><td>0x0d</td><td>Carriage return character.</td></tr><tr><td>\t</td><td>0x09</td><td>Horizontal tab character.</td></tr></tbody></table><p>The boundary of each line can be set with a vertical line character. This makes it easier to see the whitespace.
<span class=todo>*Planned Feature</span></p><pre tabindex=0><code class=language-cy data-lang=cy>var poem = &#34;line a
       |  two spaces from the left
       |     indented further&#34;
</code></pre><p>Using the index operator will return the UTF-8 rune at the given index as a slice. This is equivalent to calling the method <code>sliceAt()</code>.</p><pre tabindex=0><code class=language-cy data-lang=cy>var str = &#39;abcd&#39;
print str[1]     -- &#34;b&#34;
print str[-1]    -- &#34;d&#34;
</code></pre><p>Using the slice operator will return a view of the string at the given start and end (exclusive) indexes. The start index defaults to 0 and the end index defaults to the string&rsquo;s length.</p><pre tabindex=0><code class=language-cy data-lang=cy>var str = &#39;abcxyz&#39;
var sub = str[0..3]
print sub        -- &#34;abc&#34;
print str[..5]   -- &#34;abcxy&#34;
print str[1..]   -- &#34;bcxyz&#34;

-- One way to use slices is to continue a string operation.
str = &#39;abcabcabc&#39;
var i = str.findRune(0u&#39;c&#39;)
print(i)                            -- &#34;2&#34;
i += 1
print(i + str[i..].findRune(0u&#39;c&#39;))  -- &#34;5&#34;
</code></pre><h3 id=string-interpolation>String Interpolation.
<a class=anchor href=#string-interpolation>#</a></h3><p>You can embed expressions into string templates using braces.</p><pre tabindex=0><code class=language-cy data-lang=cy>var name = &#39;Bob&#39;
var points = 123
var str = &#39;Scoreboard: {name} {points}&#39;
</code></pre><p>Escape braces with a backslash.</p><pre tabindex=0><code class=language-cy data-lang=cy>var points = 123
var str = &#39;Scoreboard: \{ Bob \} {points}&#39;
</code></pre><p>String templates can not contain nested string templates.</p><h2 id=arrays>Arrays.
<a class=anchor href=#arrays>#</a></h2><p>An <code>array</code> is an immutable sequence of bytes. It can be used to represent strings but it won&rsquo;t automatically validate their encoding and indexing returns the n&rsquo;th byte rather than a UTF-8 rune. See <a href=/cyber/docs/toc/modules/#type-array><code>type array</code></a>.</p><pre tabindex=0><code class=language-cy data-lang=cy>var a = array(&#39;abcd&#39;)
str = a.insertByte(1, 255)
print a[0]     -- &#34;97&#34;
print a[1]     -- &#34;255&#34;
print a[-1]    -- &#34;100&#34;
</code></pre><h2 id=bracket-literals>Bracket literals.
<a class=anchor href=#bracket-literals>#</a></h2><p>Bracket literals is delimited with brackets <code>[]</code>. Bracket literals are used to initialize Lists, Maps, and Objects:</p><pre tabindex=0><code class=language-cy data-lang=cy>var list = [1, 2, 3]
var map = [ a: 123, b: 234 ]
var obj = [MyObject a: 123, b: 234]
</code></pre><h2 id=lists>Lists.
<a class=anchor href=#lists>#</a></h2><p>Lists are a builtin type that holds an ordered collection of elements. Lists grow or shrink as you insert or remove elements. See <a href=/cyber/docs/toc/modules/#type-list><code>type List</code></a>.</p><pre tabindex=0><code class=language-cy data-lang=cy>-- Construct a new list.
var list = [1, 2, 3]

-- The first element of the list starts at index 0.
print list[0]    -- Prints &#39;1&#39;

-- Using a negative index starts at the back of the list.
print list[-1]   -- Prints &#39;3&#39;
</code></pre><p>Lists can be sliced with the range <code>..</code> clause. The sliced list becomes a new list that you can modify without affecting the original list. The end index is non-inclusive.</p><pre tabindex=0><code class=language-cy data-lang=cy>var list = [ 1, 2, 3, 4, 5 ]
list[0..0]    -- []          
list[0..3]    -- [ 1, 2, 3 ] 
list[3..]     -- [ 4, 5 ]    
list[..3]     -- [ 1, 2, 3 ] 
</code></pre><p>The <code>+..</code> invokes the slice operator with an end position that is an increment from the start: <span class=todo>*Planned Feature</span></p><pre tabindex=0><code class=language-cy data-lang=cy>var list = [ 1, 2, 3, 4, 5 ]
list[2+..2]   -- [ 3, 4 ]
</code></pre><p>List operations.</p><pre tabindex=0><code class=language-cy data-lang=cy>var list = [234]
-- Append a value.
list.append 123
print list[-1]     -- Prints &#39;123&#39;

-- Inserting a value at an index.
list.insert(1, 345)

-- Get the length.
print list.len()  -- Prints &#39;2&#39;

-- Sort the list in place.
list.sort((a, b) =&gt; a &lt; b)

-- Iterating a list.
for list -&gt; it:
    print it

-- Remove an element at a specific index.
list.remove(1)
</code></pre><h2 id=tuples>Tuples.
<a class=anchor href=#tuples>#</a></h2><blockquote><p><em>Incomplete: Tuples can only be created from @host funcs at the moment.</em></p></blockquote><h2 id=maps>Maps.
<a class=anchor href=#maps>#</a></h2><p>Maps are a builtin type that store key value pairs in dictionaries. See <a href=/cyber/docs/toc/modules/#type-map><code>type Map</code></a>.</p><h3 id=create-map>Create map.
<a class=anchor href=#create-map>#</a></h3><p>Create a map using key value pairs inside a collection literal:</p><pre tabindex=0><code class=language-cy data-lang=cy>var map = [ a: 123, b: () =&gt; 5 ]
</code></pre><p>Maps entries can be listed in multiple lines:</p><pre tabindex=0><code class=language-cy data-lang=cy>map = [
    foo: 1,
    bar: 2,
]
</code></pre><h3 id=empty-map>Empty map.
<a class=anchor href=#empty-map>#</a></h3><p>The empty map is initialized using <code>[:]</code>:</p><pre tabindex=0><code class=language-cy data-lang=cy>var empty = [:]
</code></pre><h3 id=map-indexing>Map indexing.
<a class=anchor href=#map-indexing>#</a></h3><p>Get a value from the map using the index operator:</p><pre tabindex=0><code class=language-cy data-lang=cy>print map[&#39;a&#39;]
</code></pre><p>Maps can be accessed with the <code>.</code> dot operator as well:</p><pre tabindex=0><code class=language-cy data-lang=cy>print map.a
</code></pre><h3 id=map-operations>Map operations.
<a class=anchor href=#map-operations>#</a></h3><pre tabindex=0><code class=language-cy data-lang=cy>var map = {}
-- Set a key value pair.
map[123] = 234

-- Get the size of the map.
print map.size()

-- Remove an entry by key.
map.remove 123

-- Iterating a map.
for map -&gt; [val, key]:
    print &#39;{key} -&gt; {value}&#39;
</code></pre><h3 id=map-block>Map block.
<a class=anchor href=#map-block>#</a></h3><p>Entries can also follow a collection literal block.
This gives structure to the entries and has
the added benefit of allowing multi-line lambdas.
<span class=todo>*Planned Feature</span></p><pre tabindex=0><code class=language-cy data-lang=cy>var colors = []:
    red: 0xFF0000
    green: 0x00FF00
    blue: 0x0000FF
    dump func (c):
        print c.red
        print c.green
        print c.blue

    -- Nested map.
    darker []: 
        red: 0xAA0000
        green: 0x00AA00
        blue: 0x0000AA
</code></pre><h2 id=objects>Objects.
<a class=anchor href=#objects>#</a></h2><p>Any value that isn&rsquo;t a primitive is an object. You can declare your own object types using the <code>type object</code> declaration.
Object types are similar to structs and classes in other languages.
Unlike classes, there is no concept of inheritance at the language level.</p><h3 id=fields>Fields.
<a class=anchor href=#fields>#</a></h3><p>Fields must be declared at the top of the <code>type object</code> block using <code>var</code> or <code>my</code>:</p><pre tabindex=0><code class=language-cy data-lang=cy>type Node object:
    var value int
    var next  any
</code></pre><p>When fields are declared with <code>my</code> instead, they become dynamically typed.</p><h3 id=instantiation>Instantiation.
<a class=anchor href=#instantiation>#</a></h3><p>New object instances are created using a leading type name and the field values in a collection literal:</p><pre tabindex=0><code class=language-cy data-lang=cy>var node = [Node value: 123, next: none]
print node.value       -- Prints &#34;123&#34;
</code></pre><h3 id=methods>Methods.
<a class=anchor href=#methods>#</a></h3><p>Methods allow invoking a function on an object instance using the <code>.</code> operator:</p><pre tabindex=0><code class=language-cy data-lang=cy>type Node object:
    var value int
    var next  any

    func inc(n):
        value += n

    func incAndPrint():
        inc(321)
        print value

var node = [Node value: 123, next: none]
n.incAndPrint()         -- Prints &#34;444&#34;
</code></pre><h3 id=self-variable><code>self</code> variable.
<a class=anchor href=#self-variable>#</a></h3><p>Type members can be implicitly referenced inside the method. <span class=todo>*Incomplete: Only the type's fields can be referenced this way.</span></p><p>To reference members explicitly inside a method, use the builtin <code>self</code>:</p><pre tabindex=0><code class=language-cy data-lang=cy>type Node object:
    var value int
    var next  any

    func double():
        return self.value * 2
</code></pre><h3 id=type-functions>Type functions.
<a class=anchor href=#type-functions>#</a></h3><p>Type functions are declared outside of the <code>type</code> block with an explicit namespace path:</p><pre tabindex=0><code class=language-cy data-lang=cy>type Node object:
    var value int
    var next  any

-- Declare namespace function inside `Node`.
func Node.new():
    return [Node value: 123, next: none]

var n = Node.new()
</code></pre><h3 id=type-variables>Type variables.
<a class=anchor href=#type-variables>#</a></h3><p>Similarily, type variables are declared outside of the <code>type</code> block:</p><pre tabindex=0><code class=language-cy data-lang=cy>-- Declare inside the `Node` namespace.
var Node.DefaultValue = 100

print Node.DefaultValue    -- Prints &#34;100&#34;
</code></pre><h2 id=enums>Enums.
<a class=anchor href=#enums>#</a></h2><p>A new enum type can be declared with the <code>type enum</code> declaration.
An enum value can only be one of the unique symbols declared in the enum type.
By default, the symbols generate unique ids starting from 0.</p><pre tabindex=0><code class=language-cy data-lang=cy>type Fruit enum:
    case apple
    case orange
    case banana
    case kiwi

var fruit = Fruit.kiwi
print fruit       -- &#39;Fruit.kiwi&#39;
print int(fruit)  -- &#39;3&#39;
</code></pre><p>When the type of the value is known to be an enum, it can be assigned using a symbol literal.</p><pre tabindex=0><code class=language-cy data-lang=cy>var fruit = Fruit.kiwi
fruit = .orange
print(fruit == Fruit.orange)   -- &#39;true&#39;
</code></pre><h2 id=symbols>Symbols.
<a class=anchor href=#symbols>#</a></h2><p>Symbol literals begin with <code>.</code>, followed by an identifier. They have their own global unique id.</p><pre tabindex=0><code class=language-cy data-lang=cy>var currency = .usd
print(currency == .usd)   -- &#39;true&#39;
print int(currency)       -- &#39;123&#39; or some arbitrary id.
</code></pre></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/fubark/cyber/edit/master/docs/hugo/content/docs/toc/data-types.md target=_blank rel=noopener><img src=/cyber/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#none>None.</a></li><li><a href=#booleans>Booleans.</a></li><li><a href=#numbers>Numbers.</a><ul><li><a href=#integers>Integers.</a></li><li><a href=#floats>Floats.</a></li><li><a href=#big-numbers>Big Numbers.</a></li></ul></li><li><a href=#strings>Strings.</a><ul><li><a href=#string-interpolation>String Interpolation.</a></li></ul></li><li><a href=#arrays>Arrays.</a></li><li><a href=#bracket-literals>Bracket literals.</a></li><li><a href=#lists>Lists.</a></li><li><a href=#tuples>Tuples.</a></li><li><a href=#maps>Maps.</a><ul><li><a href=#create-map>Create map.</a></li><li><a href=#empty-map>Empty map.</a></li><li><a href=#map-indexing>Map indexing.</a></li><li><a href=#map-operations>Map operations.</a></li><li><a href=#map-block>Map block.</a></li></ul></li><li><a href=#objects>Objects.</a><ul><li><a href=#fields>Fields.</a></li><li><a href=#instantiation>Instantiation.</a></li><li><a href=#methods>Methods.</a></li><li><a href=#self-variable><code>self</code> variable.</a></li><li><a href=#type-functions>Type functions.</a></li><li><a href=#type-variables>Type variables.</a></li></ul></li><li><a href=#enums>Enums.</a></li><li><a href=#symbols>Symbols.</a></li></ul></nav></div></aside></main><script src=/cyber/highlight.min.js></script><script>hljs.registerLanguage("cy",function(){return{keywords:{keyword:["func","import","for","coinit","coresume","coyield","return","if","else","as","while","var","my","object","with","caught","break","continue","switch","pass","or","and","not","is","error","throws","true","false","none","throw","try","catch","recover","enum","type","case"],type:["float","string","bool","any","int","List","Map","rawstring","symbol","pointer","dynamic"]},contains:[{scope:"string",begin:"'",end:"'"},{scope:"symbol",begin:"#",end:/\w(?=[^\w])/},hljs.COMMENT("--",`
`,{contains:[]}),hljs.C_NUMBER_MODE]}}),hljs.highlightAll()</script></body></html>